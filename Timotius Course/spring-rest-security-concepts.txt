om shree ganeshaya namah
om shree sita rama lakshman hanuman

- This Course is about learning REST API security threats and how to prevent them
- Whether we develop REST API internally or publicly security is very important aspect
- So it is very important to learn basics of security threats and how to prevent them

- Writing good security followed code is not giving 100% gurantee on secuiring from all threats and risks

- Spring Boot provides spring security project to handle some of risks or threats
  but we will not use them in this course and write handson code to learn it better
  
- Every digital Device we use have security risk like website, application, similarly REST API have also security risk
  REST API exposes entry point for other softwares to interact with our software , system, network,data
  hacker can hijack and misue the data, network , close the system etc
  We must do penetration testing to evaluate security level
  
a. SQL Injection Threat
- SQL Injection threat can occur when we are dynamically creating SQL based on API input
  Application might not know safe and unsafe inputs and since it is created dynamically based on user input
  unsafe sql will still get executed and cause issue
  eg: an API takes SQL from client and run it
  very dangerous as instead of selec query client can send delete query
  Note: Remember using framework does not mean application is safe from SQL Injection Threat
  In summary never use SQL string to be fetched directly from api input
  Also it is very dangerous to create sql using string append as user can send dangerous input
  eg: findByEmail(String email){
		var sql = "select * from user where email="+email;
		
  }
  what is user sends delete query also
  eg: email = kanishk@gmail.com; drop table customer;
  since we did not validate this before it will also get executed
  
  Calling a stored procedure to update a field in customer can also be risky
  even frameworks like spring data jpa can not help save this
  
- It is a common myth that post body is secure
  for https body param are encyrpted and are safe to be read
  however that does not mean it is safe from sql injection
  if we are building an sql query dynamically from request body param hacker can send dangerous query
  once in back end it is appended with sql append string it will get executed and can be very dangerous
  like it can check for mysql/postgres sql version, view all the tables and their schemas
  even drop the table : woof
  even though the endpoint is https request body can still be seen by the browser client
  if hacker runs an app, and in netwrok tab see any sql query passed from browser F.E to API
  he can understand that there is chance of weakness in terms of sql injection  
  
- If we use jdbcTemplate with dynamic sql string creation with input from request api either in
  path param, request param, headers or request body is very dangerous
  these things will be safe using spring data jpa, as there is no dynamic sql creation
  however if we use sql procedures
  or use @Query to create SQL string using input from F.E it is not safe

  it will be safe to use jpa crud repository method and sql injection params will be ignored
but if we are using @Query to call custom SQL that is dynamic can be dangerous  

om shree ganeshaya namah
om shree sita rama lakshman hanuman

- Safe way to avoid SQL Injection is using prepared statements instead od using string sql with dynamic append
  a prepared stament is staement with placeholders like ? and that gets populated with user input
  It means the sql statement can not be modified only the placeholders are modified
  In case of sql append string complete sql can be modified as a string
  but prepared staement is safe as sql statement is never modified only placeholder values are modified
  hence if user input contains sql statement that wont be executed as statement 
   but instead will act as value of that column/placeholder

- Another approach can be to filter the request during validation using filters or interceptors
  if query param/ headers/ request body contains dangerous sql commands like delete, drop we should send bad request status code in validation itself
  Also avoid using stored procedures as that can not be safe from sql injection
  Apart from code we should give specific role based authority to different user
   -> like never share super/admin user to everyone including the application driver and jdbc connection  
   create specific user in db with specific restricted role and use that as user in jdbc driver in application and users
    dangerous commands like drop table, drop column, delete should be not given even to jdbc client user in application
	should not be able to create another user also (admin access)
	
- In case of Prepared staement we have ? set for placeholders
  but order of these matters and also in case if there are so many placeholders it can make mistake
 due to so many placeholders dev might not set data values in order
 so we can use NamedParameterJdbcTemplate in which we can assign placeholder with a name
  and in source data map we can keep key value in any order and
  it works so long as key name in data map is same as that in placeholder name in prepared statement 
  Note: Remember even prepared statement can not save us from stored procedures based sql injection
    
- Remember that during exception spring by default show the full stack trace
  during sql injection error it can contain internal deails like sql query table ,clolumns , sql version etc
  hacker can get these sensitive data base related details and misuse
  so we should always never show inner details and create custom generic exception handler
  and show generic error message with hidden internal implementation like d.b , framework , programming language, drive etc

- Apart from creating request validation filterting like sql injection interceptors
  we can also do validations on request payload , this can also save us from sql injection issues  
  
om shree ganeshaya namah
om shree sita rama lakshman hanuman

- Since framework like spring data jpa repository uses prepared statement the method sql creation approach works fine
  however sql injection threat is possible for jpql query built from string and dynamic fields from client
  eg: we create sql using string append following jpql or sql and then using entitymanager to call query
   same danger like using jdbc template
- Remember that dangerous sql injection does not always mean deleting data
  but be able to view restricted data is also dangerous as data theft   
  
- Best way to implement security is to do in multiple layers
  if one layer got penetrated another layer can save it
  limit the damage in worst case

- Different penetration layers to be safe from sql injection
code level
a. prepared statements
b. bad data filtering and validation
c. never use triggers/db procedures
d. limited access to the app for db access
extra ones: outside code level
e. rotate the password
f. audit trail
g. use WAF

om shree ganeshaya namah
om shree sita rama lakshman hanuman

om shree ganeshaya namah
om shree sita rama lakshman hanuman

- XSS aka cross site scripting is a web application security threat where malicious code is run on web application
  bad site/hacker inject malicious code like java script and run on web applicationin the browser
  this malicious script code might be running in browser without user knowing it in the background
  one common example:
  a. the java sript code runs on browser (malicious) query the cookie and get authorization token
  and actually hit the real application by using this token and overhit the server and try to make it overload and eventually down
  b. keylogger: Every time user click/type in browser that charachter is sent to hacker 
    and it can track things like username/password / credit card, pin etc and other sensitive data
  c. send screenshot of browser like netbanking page, sensitive site data to attacker

- Types
a. Reflective XSS : malicious script is executed on user's browser but not saved
b. Persistent XSS: malicious script is executed on user's browser but saved in the application 
  and can be executed n times
   eg: hacker injecting script and taking credntials from cookie and storing in its d.b for persistence

- In XSS threat hacker inject malicious script in user's web browser and get it executed without user knowing in background
 How hacker in injecting these malicious scripts
a. via emails, if user open email and click link it can inject the malicious script in the browser
b. opening malicious websites
  remember these website links/email links can be shortened using url shortner making it less suspicious
  the a href link can contain malicious script code

- Even a file upload F.E functionality is a xss threat
  if we upload csv in form of html and javascript code seperated by comma this can be dangerous  

- eg: We create one api that takes name as queryparam/path variable and returns ting message and append name
  using postman if we send bad string like <script> that is malicious it will be harmless
  but in case we have html css running in browser and send malicious script in name
  that script will get executed by browser and it can be in background reading cookie and sending sensitive data
  this is very dangerous while running a web app in browser
  eg: ?name=Good Morning Anna <img src='x' onerror='alert("This is XSS")'>
  remember if this is executed in brower js can be executed and here malicious code can be kept by hacker
  eg2: malicious site creates api to download a file and in the file it puts malicious java script
  this wont cause issue in postman but will have issue in browser
- The above 2 code examples are demo on how hacker can inject malicious java script code in user's browser

- Even React has holes n XSS

- XSS Thread prevention  
  XSS can occur in 2 ways
  input: if we are recieving xss vulnerable script
  to solve this we need to have validation, intercept filter for bad data
  also if needed in api accept only json/specific format as payload
  -> this means in request header content-type has to be passed and on server if accepts : content-type did not match unsupported operation exception is thrown with status code 415
  
  output: if we are sending xss vulnerable code back to brower
  solution: a. Always encode the output , never just return string but use some protocol to encode the object
   We cann use library provided by owasp encoder to encode dangerous string to client
   so that browser wont run it as plain script in case it has script
   
  b. produce always json or specific format and not just any raw data : meaning response header content-type should be filled
   -> This way browser wont parse the response as html or plain text
   it will parse it like json and hence script wont be executed in the browser
   Spring boot automatically return text/plain for string returns and application/json for any object
   even for file it will set response header content-type as application/json by default
   unless put in produes annotation parameter
   Now tough thing is to set content-type in case of file return
   as file can be audio/image/jpeg and other variation
   how to determin the type of file: do not implement use apache tika library
   The logic to find the produces/content-type of response is very important
   in demo we created a file that contains html and js script, if we return it just like this, the content-type will be application/json
   also browser will run it as script
   so if we set correct content-type : for html set as plain/text and for others use tika library then browser will be safe from this
   it will consider it as plain text and wont run the browser script from file
   
  c. in response header add xss headers to ensure safety by browser like chrome,firefox etc for xss preventions
   X-XSS-protection: 0
   X-Conten-Type-Options: nosniff : so that browser do not predict response data type 
       instead forcefully use response header content-type to parse the body
	   this way we an ensure that body is paresed to json/xml and hence wont be executed on browser as script
  
   Content-Security-Policy
  This header forces what all scripts can be run and where : this can make our system more secure in browser
   as whata all script can be executed by browser as mentioned here
   eg: download image from specific prefix url, run specific js, allow iframe or not etc
  fine tune according to our needs
  in demo we are setting Content-Security-Policy enabled for a script id
  so that script only will be allowed to be called by browser others will get rejected
  we have used filter but that is not perfect place to do and also require fine tuning
  
om shree ganeshaya namah
om shree sita rama lakshman hanuman

- In our course we have written all the security code in the API
  which in case of enterprise level be tough as API have huge code for business logic
  writing code related to huge business logic + security in same project make it less maintainable
  hence there are certain API management tools to help reduce development time for these security parts
  features
  a. Rate limiting to avoid denial of service attack
  b. token management : authentication + authorization
  these are cross cutting concern and will be needed for all the APIs
  hence it is good to have at one place and maintain at single place
  this way we can focus on writing complex business logic in APIs and let API gateway do the security and cross cutting concern
  benefit: no need of copy paste in all service 
           single place maintanibaility
           do once and use forever
           easy to read and maintainable code for business logic APIs

- API management tools provide security features by default + plugins
  plugins can plug in or out specific security or other features
  but that does not mean we need not to write security code at all
  tools like APIGEE and kong provide extension in its features using different programming language(java in kong and LUA in APIGEE)
  so in summary we can use oob features, pluggable features and even add our own features in api gateway tools

- Any external call comes via firewall
  Firewall is of 2 types: 
  a. netwrok firewall: security on netwrok layer like same vpc outside vpc etc
  b. WAF: web application firewall : provides security on http layer for http applications
  
Flow
  
 external client ->        network firewall ->           WAF ->                     API gateway                    ->               APIs                                
  
  external system VPC    provide netwrok 
                        vpc level security              web based and http     more security like authentication
						like xternal or internal         security              token, rate limiting etc   
						vpc based on security group                             load balacing among api instances
  
  
om shree ganeshaya namah
om shree sita rama lakshman hanuman

om shree ganeshaya namah
om shree sita rama lakshman hanuman

- Denial of service attack was meant to deny legitimate users from accessing APIs
  attacker hits the API huge amount of times to overload/overburden the API servers 
  hence it causes downtime and slowness for actual legitimate users
  Attacker can use single IP machine but that can be more easily traceable and block
  Sometimes attacker uses multiple IPs to overhit and overburden server that is very tough to inspect and block:
  -> Distributed Denial of Service aka DDOS attack
- Unlike SQL injection and XSS DOS do not make use of weakness in code
- Even to execute very simple basic code it require some bit of resource
  To Server a request API code might need below resources
  CPU utilization, RAM , har disk space, Socket/Network I/O for external APIs,D.Bs etc, Server Threads
  In DOS attack so many requests are called concurrently that all these resources are eaten up
  which causes legitimate users to either have slowness or complete timeout causing complete deny of service
  also DOS can cause complete shutdown of servers causing complete downtime  
  
- Another approach of DOS is by sending request within rate limit
  but in each request it has so many request body and so much task to process it eats all resource of server apis
  eg in bulk create it request for 1000s of items to be created and request is send within TPS rate limit
  or response payload is huge  
  
- Approaches to solve DOS attacks
a. IP witelisting/restriction
   In firewall always allow only specific client ips to pass through the firewall can be able to call API
  this way we can exsure that bad attacker machines are not hitting our API server and eating resources
  we can use whitelisting approach when all are blacklisted except configure api and firewall reject such requests
  in case of cloud based client we can whitelist the CIDR range
  -> For APIs that are public we can go with blacklist approach
   all client IPs are whitelisted except the ones added in blacklist IPs where we keep known attacker IPs
   this is reaction as IP was bad in the past in project or other project
b. Rate Limit
   Reject the requests that are comming at an incomming rate > the rate of reques we can handle
   so that resource is not overburdened
   legitimate clients can retry after some time as error code 429 will be sent in response header
c. Use Pagination:
   in case of bulk response we can use this to ensure huge data is not passed

- In the Deployment architechtural diagram presented
   client -> network firewall -> WAF -> API Gateway -> Load Balancers -> APIs

  If multiple modules in above are providing rate limit and ip whitelisting we should do as early as possible to the client
  so that less resources in each module is overburdened
  eg: if we do rate limit in REST api and eventually reject request then already other module (WAF, API gateway, Load Balacners)
  are already exhaushted so best approach in DOS prevention is to prevent as early as possible  in the request layer ' s module
  Note: Just like other security preventions even rate limiting should be kept at multiple layers of penetration
  It is possible that in WAF we might misconfigure or there is some technical bug so other layer can protect from it
  This concept is known as defense in depth and is common in most of security principles
  i.e provide security in multiple layers, also we should not do the same in all layers
  as running the same seurity code in all layer will add latency and hence cause slowness in APIs  
  
  
- Encoding the data is converting data in format
  nothing to do with security this is just so that other systems can understand the data
  eg image is encoded in binary format so that it can be sent but it has no security concern
  Types of encoding: Base64 encoding, URL encoding etc
 
- In case of URL encoding always encode the query parameters but the whole url need not to be encoded
  just query parameter string encoding is good

- Encryption is a security concern
  goal is that only valid users can read the data and no one else
  eg: AES , DDDES

- Hash is a security concern
  used for data integrity in form of checksum/signature
  if some part of data is changed we can know that it is changed, but what part of data is changed we can not know
  unclike encryption in hash we can not get back the original data
  we can only identify if data is changed or not as it is checksum/signature based, original data can not be retrieved  
  Result of hash function is a string that has following features
a. if 2 identical data is hashed using same hash function then hash string will be identical
b. if data is different even by a single char the hash will be different
  eg: Bcrypt, SHA256 Argon2
  
Salt: Before hashing extra random charachters are added
  so original data + random charachters(salt) are appended and then hashed for extra security
  we need to validate 3 things in order to have data integrity (data not changed)
  salt, data, first hash
  Steps: we rehash the string and salt appended string
    if this rehash == hash one then data is not changed
	
  eg: kanishk and krishna uses same password
  but random charachters salt is added that will be different for them
  then this combination is hashed, hence hash of these 2 will be different
  we should always hash the password with salt and not encryption (salt should be unique for each user)
  it is because in encryption if private key is accessed by dev/qa they can decrypt to get original data
  in case of hash we can not get the original data onnly can check if 2 string have same hash and data is not changed  
  
om shree ganeshaya namah
om shree sita rama lakshman hanuman

- Base64 Encoding is useful in file transfer: convert base64 encoded string and pass over network
  but it has disadvantages
  a. It has more size (around 20-30%) than normal file : like Base64 encode file size > actual file size
  b. Additional processor work to be done by sender and reciever
  c. no security
  Better approach in file transfer among 2 applications
  -> Either get a URL like S3 and download the file
  -> MultiPart File
  
- Benefit/Reason of doing Base64 Encoding in URL is to escape the query parameter
  eg: some special charachters are there in queryparam/path then it can be easily passed via Base64 URL Encoding
  eg: abc.com?options=create/update
   this will create a path after '/' and hence better to base64 encode the parameters
  If this is not done then the reciever server might understand it wrongly so to be safe
  we encode using specific convention and decoding of URL get you exactly what was passed  
  
- Benefit/Reason to use Encryption is to ensure data is saved and only valid user can decrypt and use it
  Encryption can also be done on data base level : encryption at rest
  If data base is leaked the data will be still encrypted and hacker wont be easily be able to get the data for misuse
  
- Benefit/Reason of using hash in APIs
  we can validate if request body was not intercepted and changed
  somewhat similar to what JWT does: data integrity
  
- HMAC : Hash based message authentication code
  Ensures that the data is not modified by network interceptors
  In HMAC client has to send extra data related to data validation
  API provider identifies a rule and share that with the client
  also shares the secret key with the client(unique secret key for each client)
  
- Steps
  a. Client uses HMAC method and provide input as secret and message(based on format)
  b. It calls Server to get HMAC token : if all is validated server provides HMAC token
  c. in header client can set this hmac token
  d. server validates that request body is not changed
     Server already knows the secret key and rule and create HMAC code and compare this with the header one
    if correct then data is not changed + client is authenticated
  We can use nonce salt: meaning random unique string everytime

- In real life Client need to set X-Register-date header in request

om shree ganeshaya namah
om shree sita rama lakshman hanuman

om shree ganeshaya namah
om shree sita rama lakshman hanuman

- So Far we have exposed APIs to public and everyone
  but on production standard we would expose the APIs to legitimate users 
  we must know who all are using our APIs, good for security to limit APIs to legitimate users
  Benefits
  a. Securing APIs to legitimate users : limiting
  b. view who all are using our apis
  c. who is abusing or overusing our apis
  d. monitoring what all clients are using our API and to waht level
  e. different late limit for different user: for premium better rate limit and less for free user
  -> provide username/password to authenticate and tell who the client is
  
- Bad Authentication approaches(Don't do these)
  a. Passing username/password as query param or path variable:
        bad the browser can cache it and other can see the username/password in browser history
  b. Thinks that Authorization header is secured and save the base64 encoded password without using hash and salt
  c. We must choose authentication to be done on APIs that are needed
     eg: for health check we need not this but for other data related apis we must add authentication
	 it is easy to implement based on url pattern

- In case of Bcrypt hash the salt is contained in the hash itself
  but for other algo in shing we have salt nd hash seperated
  so we need different column in basic authentication table for salt and hash
  for bcrypt we can keep salt as empty as that will be kept in hash column itself
  for other algo we can make use of both columns as hash wont contain salt in itself

- HTTP provide response header WWW_AUTHENTICATE where we can tell client what kind of authentication it needs
  during failure in fiter we can set it but its bad idea as it can have security issues
  sometimes telling less to client is safe and secure
  
- Data Transmission threat
  You go to cofee shop see a free wifi with name star bucks high sppeed free
  this looks intresting but might not be actually owned by starbucks: it might be actually a bait
  maybe some attacker have used a wifi portable device to show this
  if we connect to this wifi and go to http website(unsecured) all data will go in plain text
  if sensitive data like username/password/credit card is sent it will be in plain text
  hacker can intercept it and see the details using some packet sniffing tools
  this is called packet sniffing  
  
  -> IF api was https based then hacker can intercept the data but can not decrypt and understand it

- How to setup HTTPS on server
  install TLS/SSL certificate on server side shared by Certificate authority
  CA or certificate authority is trust store for all valid SSL/TLS certificates
  Browser calls CA to get the public key present which was shared during certificate sharing by Server to CA
  so actually only public Certificates are trusted by browser
  but for development purpose we can use self signed certificates
  
- In production it is not good practise to install ssl in each microservice deployed across multiple servers/machines
  better to install in Load balaner/API gateway level and it can show https layer for outside traffice
  and internally Load balaner/API gateway calls API using http via internal netwrok within private VPCs 
  
- Best practises for HTTPS:
a. Always expose APIs over HTTPS
b. For Web application like react/angular if http is called forcefully redirect to https
   eg: http://www.google.com forcefully goes to https://www.google.com
c. In response always set header HTTP strict transport 
   this forces browser to call further request forcefully in https
  
- Logging is not just important for tracing and debugging purpose but also for security
  if we add audit log and analyze it can help in security also
  Audit log means logging what all operation are getting executed and by which client and how
  Audit means what all operations are getting called by client with this 
   we can see in logs if any potential security threat is getting executed  
   if any dangerous commands are getting executed by clients
   
- Audit logs should be stored in durable location like database or file storage
  Why : So that in case due to DOS or other hacking our system machine or process goes down
  we still have the audit log to find the cause of beeing down , maybe security thread cause our servers to go down
  Where to keeps logs:
  a. Simple log text file: Shared across EBS in AWS for persistence
  b. ELK stack
  c. database
- Audit log shall be visible to only trusted resources as it shows huge inner operations and implementations
    if it gets leaked system will get hacked easily 
  There is a chance of theft is one person have all access
  hence audit logs shall be shown to limited people and that should not be highly technical to save from fraud

- What to log depends on organization and API
  suggestion:
  API response time including server wait time in ms
  HTTP Verb
  URI Path
  optional query string
  client who used this: username/token etc : not password
  request body: except sensitive data like credit card/password
  
- Not using audit log is a threat
  as if no audit log present we will never be able to see that we faced any security threats
  as we will not be able to monitor operations/actions performed by clients
  
- We can implement audit logging using spring boot oob filter for each request
  CommonsRequestLoggingFilter will generate logs but only in specific format
  we still need to parse it get all the data and store in data store like elastic
  to make this parsing easy we can use loggly tool instead 
  or also we can use logstash to parse this and push correct formatted data in elastic
  for simplicity in code demo we are using loggly to parse this data and push to simple log file and not elastic
    
om shree ganeshaya namah
om shree sita rama lakshman hanuman

- So Far we have learned how to do basic authentication of user and using audit log we know who is accessing what
  but so far one authenticated user can access any of our apis
  this is not good approach
  as some api endpoints might be admin(only admin must access),
  some might be write/read(read user , write user) ,
  some will be info  (any user can access it)
  a hacker can create random users and if admin apis are open for all, hacker can do data theft/data loss

- Access Control List:
  Same as principle of least authority: give exact priviledge to the users not more nore less
  giving more access can be dangerous and security concern, giving less will hinder the user's work
  Similarly on API endpoints if we apply this practise it is known as ACL
  List of users based on access
  meaning a map that has key as role and value as list<user>
 meaning in ACL we have list of users with their access mapping  

- Authentication is the process of identifying who you are
  Authorization is the process to identify if you have access/permission to do the task or not
  good practise = authentication + authorization

- Which HTTP response status code to use during failure
  a. 401: Authentication failure
     username/password is incorrect, no auth in request header
  b. Authorization failure
     authentication success but ACL failed
	 auth request header present but is expired or do not have that priviledge
	 
- Up untill now we have learned basic authentication, that work fine bt a drawbacks
 a. username/password is still encoded to base64 format that anyone can decode
    hacker can easily intercept and decode it
 b. password validation happens using hash which is slow and can be made faster
    hash is designed to be processed slowly so taht hacker can not break it
    now hashing is not very slow like taking > 30-40 seconds but it is still slower than like comparing 2 strings
	and for modern applications users count and api request count will be huge
	and if for these scalable systems we are using hash validation for basic auth for each request
	hashing step will eat a lot of cpu operations and hence cost of machines in cloud/on premise will increase
	this is done only for security and business logic will still need more powerful machines and hence more cost
 c. Not recommended to use basic authentication for web site login functionality
    as username and password can be intercepted as plain text part of Authorization request header
    Extremely bad practise to use basic auth for ui based login
    for application to application basic auth is still fine but for web application login it is a blunder

- For web application login we can use token based authentication
  Steps in token based authentication
  a. User uses web front end to call /login endpoint provided by back end
  b. B.E authenticats username/password and provide token
  c. F.E can pass on token to B.E APIs and B.E can validation this token
    remeber the token will be time limitted

- We will store the token in session cookie
  session cookie is not persistent in browser instead remain in browser session
  once user closes the browser the data in this cookie will be lost, we can set max age for these cookies
	
- SessionCookie token works but it has security vulnearbility
  -> session fixation attack
  Attacker calls the login api provides basic auth credentials and get session cookie token
  then attacker shares a link to victim by appending the session cookie id
  victim logs into the system but since the method request.getSession(true) uses existing session
  uses cookie shared by hacker
  now hacker can call any api as it has the same session cookie as that of the victim
  -> CSRF : cross site request forgery
    Victim logs into the system and session cookie gets created
    Victim click the link shared by hacker and hacker have code that takes the session cookie in browser
    and run scipt coe on browser to hit server with bad data like bad comment etc

- Threat prevention for session fixation attack and CSRF
  a. use random session id after user succesfully logs in
  b. have limited time set for session cookie
    this way hacker will have smaller window to attack and trouble
  c. Set cookie security attributes on session cookies
    -> httponly: if set to httponly a cookie data can not be read by javascript code in browser
               -> this saves us from csrf attack to some extent
    -> secure: can only be called via https only
  d. set samesite cookies : only when ui and back end are running in same server domain	
  
- code solutions for session fixation threat
  use request.getSession(false)
  if not null invalidate this and then create new session
  now hacker's session and victim's session will be different even thout victim's url contains cookie id

- code solutions for csrf
  provide the session id to client during login after hashing it
  in request header client must pass this token
  server validates the cookie as well as this token using secure util methods of string comparing  
  
- Even simple operations like String comparison can be security threat
  java String equals comparison works like it returns false on first unmatching charachter
  so hacker can use the reponse time to predict the charachter
  and some how predict the hash
  even though other things can make it very tough as response time of api depend on a lot of things
    like random G.C, server latency, netwrok latencym load balancer latency
	 everything mentioned above is random so predicting with time latency is not easy
  but if we want to be super safe we can use secure methods to compare strings
  ----- hence to compare strings specially csrf headers or othher client request strings with server strings
  we must use MessageDigest.equals that do not let hacker predict hash based on time it took to calculate string comparison  
  
om shree ganeshaya namah
om shree sita rama lakshman hanuman

- While deploying web applications and REST api we can have different domains and subdomains
  eg: F.E running in domain fe.example.com and B.E running on be.example.com
  By Default the access from different domains/subdomains will blocked as part of Same origin policy(SOP)
  eg: in our session cookie html it will work as localhost
  but if using 127.0.0.1:7001/sessioncookie.html the ajax call will not work
  as server is running on localhost domain and html is running on 127.0.0.1 domain
  
- Same origin policy is a web security mechanism to ensure script from one domain do not work on another domain
  Restricts script from one domain to another domain or origin
  What is an origin
  -> origin consist of 3 things : protocol://domain:port/
     does not contain the url of exact path of resources
     eg: http://localhost:7001 is one domain http://127.0.0.1:7001 is another domain
  so if we write any java script code to call API running on another origin(combination of protocol+domain+port)
   Same origin policy will not allow this
  eg:
  we are opening browser with http://127.0.0.1:7001/htmlname.html
  and in javascript code calling http://localhost:7001/api then it wont work
  but if it is    http://localhost::7001/htmlname.html it works
  also html is:  http://127.0.0.1:7001/htmlname.html
   and api url in javascript code is  http://127.0.0.1:7001/api then it works
   
 also if F.E origin is https and B.E protocol is http CORS will block it as part of same origin policy
 so by default same origin policy F.E protocol , domain and port should be same as that of B.EBS
 if anything is changed apart from url path it wont work by default unless we allow
  even if protocol changes or domain changes or even port changes it wont work by default 
  
- In CORS browser first send a small request with same signature to API back end
  if it fails it wont call the actual API otherwise calls the main AP with actual response
  this is called preflight request
  CORS is deeply explained in mozilla website
  Few important response headers for preflight and actual API calls related to CORS
  a. Access-Control-Allow-Origin : * or ip
  b. Access-Control-Allow-Methods : * or GET etc
  c. Access-Control-Allow-Headers: CORS can block even using headers value : * or custom or oob http headers
  d. Access-Control-Allow-Credentials: Allow Browser to send credentials to Back end API : 
      credentials meaning passwords, TLS certificates, cookies, session cookies
  e. Access-Control-Allow-Max-Age: seconds to cache CORS response

- Spring provides oob annotation @CrosOrigin to handle any cors features
  using annotation field we can pass all the http response headers related to cors
  annotation process automatically update the response headers
  We can use @CrosOrigin annotation at class level as well as method level
  hence we can put this to specific controller(all methods in controller are impacted)
  or method (specific controller method is impacted)
  or common configuration for all: global configuration for all APIs
  
- To examine the response headers related to CORS
  we can use preflight apis: apis that have same url and body and headers except method is Options
  Spring already handles this case of options method by default
  if client calls api with same things except method as options it consider it as preflight
  and client can see the response headers related to cors  

- To define global CORS we can create filter with order as highest precendence so that it gets called first always
  If we create globalcorsfilter the session cookie info api will stop working
  it is because the jsessionid cookie wont be present in browser as CORS disable it by default
  even enableCredentials wont help
  so login will work, but calling other apis authenticated with session cookie wont work
  hashed session id will be there in request header but jsessionid cookie will be absent
  server needs both of these to validate the request hence wont work  
  
- Hence using session cookie is not good enough for token authentication where cross origin domains exist  
  in web applications that is running in same origin session cookie based token authentication is good
  but in modern web application F.E and B.E are in different origins 
  hence we must learn token authentication without cookies
  
- Authentication token is passed in header and validated on each request
  must be fast hence we can use distributed session store like redis
  Redis in memory store is fast and have expiry feature 
  simple data structure, very fast, expiry enabled makes it perfect fit for auth token storage
  
  Which data storage to choose for storing token data (earlier stored in session cookie)
  a. Redis: simple, fast , scalable, expiry feature already present
  b. RDBMS: when traffice is low: req/res will count will be less can use this 
     but need to implement expiry thing with query to fetch valid session token only
	 
- Possible Threats/vulnearbilities while using non cookie based token
a. on client we store the token in local storage like redux etc in browser
   using XSS attacker can gain access of this token from local storage
   XSS injection is still possible
b. in token storage if we use RDBMS it can cause SQL injection attack
    in redis we are comparatively safe
   but attacker can access redis and misuse token if redis is not secured
    Redis should be TLS secured + password enabled

- Since we already covered XSS and SQL injection we must follow those practises here also	
  Here we can focus on issues arises when attacker steals token store like redis/db access 
  To solve this we can use hmac to authenticate the user and data integrity
  we will hmac the token with specific format and use private secret key(not to be shared)  
  this way even if some one hacks the token store still it can not use it
  because hmac secret key and rule to create mesasge is not known by hacker
  
- In code we have hardcoded the secret key and encryption keys that is bad
  as bot can crawl the code and get these
  better to store in seperate file outside code
 a. Keep secret outside the code constants and move in configuration file like yaml , properties etc
 b. do not commit this file in git as hacker can scan from there
 c. keep the content as encrypted in storage
 d. use kms tools in cloud or on premise like hashicorp vault 

om shree ganeshaya namah
om shree sita rama lakshman hanuman

- Storing tokens in session store on server side is convenient
  however there are some maintainace cost in that: eg redis cluster cost
  Hence we can use stateless tokens that gets rid of  session store  
  -> stateless token means we do not store session store neither in cookie or any other data base or cache store
  
- During succesful login we can send the stateless token to the client it can store it and pass as header 
 for server side authorization and authentication
 all the data to validate the client will be present on this token itself
 Since alldata to understand , authenticate and authorize is present on this stateless token, 
   -> no need of having token store as seperate cluster/node
- There is a standard way of creating stateless token : using JWT or json web token
  JWT is just a string containing three parts seperated by '.'
  Header.Payload.Signature
  Header : JSON object containing fields like algorithm used for encryption in Signature object
           this specific object is base64 encoded string, after decoding we can view the JSON
  Payload: Payload is the actual data in JSON format in plain way, this JSON is base 64 encoded
  Signature: Base64_encode(encryptionAlgoAsPerHeader(Base64_encode(Header) + "." Base64(Payload), Secret_key)))
  for hmacc we will have hmac algo that needs secret_key  
  hence anyone can not understand the signature until they have secret key: hence JWT is secure
  
- Since JWT is a standard for different use cases specific field exists for header and payload
  not neccessary to use all of them
 but it is good practise to use these fields if needed in project 
 hence same field will exist across project for standardization and new dev will easily understand it
 we can add our own fields
 
 OOB JWT standard fields for headers:
  { "typ": "JWT"
    "alg" : "HMC256"
	"kid" : "" , on server we can store multiple secret keys
	   , we can have entry mapping with this data as key and value as actual secret key
   	   so that we can manage multiple secret keys
   "jwk" : bad to use : hacker will get secret key and data will be lost	
   "jku" : url of the secret key: acn also be dangerous if key is on cloud or public network
  if the secret key is intercepted any hacker can create JWT tokens and do DOS attack easily
  hence secret key must be extremely secured and roatated
  Question: Why not send the jwk and use https, as interceptor wont be able to decrypt the data
  it is because the hacker can actually use website and using browser get this data from his local browser
  hence it should be https enabled + hmac encrypted with completely safe secret key
  
  OOB JWT standard fields for payload: aka payload claims (payload json field is aka payload claims)
  {
   "iss"  // issuer of the token
   "sub" : //subject
   "aud" : //audience to recieve token
   "exp" : //expiry time of token in EPOCH
   "nbf" : //jwt valid start time 
   "iat" : //issued at time
   "jti" : //jwd id : unique id for each unique JWT
   
   //custom private claims
   // "role"
   
   also just like header fields , we can also create custom payload fields/claims
  }  
	  
- Threat in JWT : in 2015 tim mclean found vulnriblities in JWT libraries that on changing the headers hacker was able to change algo
  not just that hacker changed the header in a way to make none algo meaning no validation was done by jwt library	  
 
- Remember JWT token validation ensures no use of state store
  so we do not have feature to logout before the token expires
  in the case of redis store/ session cookie token validation we sored the token so we could remove it
  after expiry time and logout initiated token can be removed from token store
  but in case of JWT since the token store do not exist we can not remove them before actual expiry time
  hence logout can not actually remove the token

- JWT threat prevention
a. Do not use caesar based encryption or similar weak encryption for signature creation 
    better use hmac 256 or similar powerful and secured algo
b. use security library from trusted source and do regular secret key updates	
c. in pure JWT implementation there is no token store so keep expiry time less 
    since user can not manually logout using pure JWT
d. use hybrid JWT token for logoutable JWT
   here JWT is also stored on server state store, so logout before actual expiry is possible
e. in case HMAC key is leaked we can revoke/remove all the token present on this session store  

- JWT is a common term , it is just a specification and have different implementation
  what we have implemented is JWS: json web signature
  Types of implementations:
  JWS : json web signature, most common implementation, when people say JWT most common it means JWS
   in this the header and payload is just bas64 encoded
   what if there is some sensitive data field in payload's claim or header, like apiKey
   hacker can intercept it over network and read the sensitive data
  JWE : json web encryption
  consist of 5 parts : first part is also header just like first part of JWS
  In this the aim is to encrypt even header and payload claims
  so that sensitive data can be passed as part of header fields and payload claims in ecnrypted way
  so hacker intercepting the data can not read it unlike normal base64 encoding
  5 parts of JWE
  header(aka JOSE) . encrypted key . initializing vector . authentication tag
   
- Not all JWT libraries support JWE , auth0 support JWS but not JWE
  whiile using jwe debugger we can not decrypt JWE token
  
om shree ganeshaya namah
om shree sita rama lakshman hanuman

- JWT is good approach for authentication but sometimes we need simpler approach, as JWT is complex
  JWT is complex to implement on server and client side both and tougher to understand
  when we need simpler approach of authentication we can use API key

- An API key is nothing but a simple alphanumeric string that can be passed with request for authentication 
  it can be passed as request param or request path variable but both approach is bad
  it is because browser can store this and on public computer this can be exposed
  better to attach as custom header in request
  Typically API keys are long lived and hence can be a security threat if it is stolen by hacker
  hence we must use API key along with additional layer like IP whitelisting and other netwrok level security
   + ACL

   
- Every company wants to provide REST APIs which is highly secure but still want many consumers to access them
  also ease of access shoule be good along with high security: thats the goal 
  earlier we used to provide username/password for authentication
  but oauth came so that password need not to be shared for accessing rest apis
  oauth allows restricted access to secured resources, without giving password
  
- grant types in oauth 2.0
a. authorization code
b. implicit: same as authorization code, 
  however client application recieve access token once resource site redirect to client site
c. password : client itself ask for username/password both, not good
   but this is used whem client is front end : either this or PKCSE approach
   in PKCSE client is F.W app like web browser or ios/android app that can not store client secret
   in password also client is F.E hence client secret can not eb stored there
   so back end server save the client id and secret and do oauth flows for F.E   